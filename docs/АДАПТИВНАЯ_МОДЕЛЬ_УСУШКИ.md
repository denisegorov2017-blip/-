```python
class AdaptiveShrinkageModel:
    def __init__(self):
        # Словарь процентов излишка по номенклатурам
        self.surplus_rates = {}  # {nomenclature: surplus_rate}
        # Средний процент излишка при поступлении (для обратной совместимости)
        self.average_surplus_rate = 0.0  # 0% по умолчанию
        
    def set_surplus_rate(self, surplus_rate, nomenclature=None):
        """
        Установка процента излишка при поступлении.
        
        Args:
            surplus_rate: Процент излишка (например, 0.05 для 5% излишка)
            nomenclature: Номенклатура (если None, устанавливает глобальное значение)
        """
        if nomenclature is None:
            # Установка глобального значения (для обратной совместимости)
            self.average_surplus_rate = surplus_rate
        else:
            # Установка значения для конкретной номенклатуры
            self.surplus_rates[nomenclature] = surplus_rate
    
    def get_surplus_rate(self, nomenclature=None):
        """
        Получение процента излишка при поступлении.
        
        Args:
            nomenclature: Номенклатура (если None, возвращает глобальное значение)
            
        Returns:
            float: Процент излишка
        """
        if nomenclature is not None and nomenclature in self.surplus_rates:
            return self.surplus_rates[nomenclature]
        return self.average_surplus_rate
    
    def _correct_for_surplus(self, data, nomenclature=None):
        """Коррекция данных с учетом излишка при поступлении"""
        # Получаем процент излишка для данной номенклатуры
        surplus_rate = self.get_surplus_rate(nomenclature)
        
        if surplus_rate == 0:
            return data.copy()
        
        corrected_data = data.copy()
        
        # Корректируем начальный баланс и приход с учетом излишка
        if 'initial_balance' in corrected_data:
            corrected_data['initial_balance'] = (
                corrected_data['initial_balance'] * (1 + surplus_rate)
            )
        
        if 'incoming' in corrected_data:
            corrected_data['incoming'] = (
                corrected_data['incoming'] * (1 + surplus_rate)
            )
        
        return corrected_data
    
    def predict_with_adaptation(self, t, 
                               environmental_conditions=None,
                               product_type=None,
                               date=None,
                               initial_balance=None,
                               nomenclature=None):
        """
        Прогноз усушки с учетом адаптационных факторов и излишка.
        
        Args:
            t: Время в днях
            environmental_conditions: Условия хранения
            product_type: Тип продукции
            date: Дата для сезонной адаптации
            initial_balance: Начальный баланс (для коррекции излишка)
            nomenclature: Номенклатура (для учета излишка)
        """
        # Базовый прогноз
        base_prediction = self._exponential_model(t, **self.base_coefficients)
        
        # Применяем адаптационные факторы
        adaptation_multiplier = self._calculate_adaptation_multiplier(
            environmental_conditions, product_type, date)
        
        # Получаем процент излишка для данной номенклатуры
        surplus_rate = self.get_surplus_rate(nomenclature)
        
        # Корректируем прогноз с учетом излишка при поступлении
        if initial_balance is not None and surplus_rate != 0:
            corrected_balance = initial_balance * (1 + surplus_rate)
            correction_factor = corrected_balance / initial_balance if initial_balance > 0 else 1.0
            return base_prediction * adaptation_multiplier * correction_factor
        
        return base_prediction * adaptation_multiplier
```

#### 7.4 Пример использования
```python
# Создание модели
model = AdaptiveShrinkageModel()

# Установка процента излишка для конкретной номенклатуры
model.set_surplus_rate(0.05, "СКУМБРИЯ ХК")  # 5% излишка для скумбрии
model.set_surplus_rate(0.10, "СЕЛЬДЬ ХК")    # 10% излишка для сельди

# Данные для адаптации
data = {
    'initial_balance': 100.0,  # Документированный остаток
    'incoming': 0,
    'outgoing': 0,
    'final_balance': 99.75,    # Фактический конечный остаток с учетом излишка
    'storage_days': 7
}

# Адаптация коэффициентов (автоматически учитывает излишек для конкретной номенклатуры)
coefficients = model.adapt_coefficients(data, nomenclature="СКУМБРИЯ ХК")

# Прогноз усушки для нового периода с учетом излишка
forecast = model.predict_with_adaptation(
    t=7, 
    initial_balance=100.0,
    nomenclature="СКУМБРИЯ ХК"
)

print(f"Прогноз усушки для СКУМБРИИ ХК: {forecast:.2f} кг")

# Для номенклатуры без установленного излишка будет использовано значение по умолчанию
forecast_default = model.predict_with_adaptation(
    t=7, 
    initial_balance=100.0,
    nomenclature="ОКУНЬ ХК"  # Не установлен излишек, будет использовано значение по умолчанию
)

print(f"Прогноз усушки для ОКУНЯ ХК: {forecast_default:.2f} кг")
```

### 8. САМООБУЧАЮЩАЯСЯ МОДЕЛЬ

#### 8.1 Алгоритм самообучения
```python
class SelfLearningShrinkageModel:
    def __init__(self):
        self.performance_history = []
        self.model_versions = {}
        self.best_model = None
        
    def learn_from_results(self, actual_results, predicted_results):
        """Обучение на основе сравнения прогнозов с реальностью"""
        
        # 1. Расчет ошибки
        error = self.calculate_prediction_error(actual_results, predicted_results)
        
        # 2. Обновление истории производительности
        self.performance_history.append({
            'timestamp': datetime.now(),
            'error': error,
            'model_version': self.current_version
        })
        
        # 3. Адаптация параметров обучения
        if error > self.acceptable_error_threshold:
            self.adjust_learning_parameters(error)
            
        # 4. Создание новой версии модели при необходимости
        if self.should_create_new_version(error):
            self.create_model_version()
            
    def auto_tune_parameters(self):
        """Автоматическая настройка параметров"""
        
        # Анализ истории для оптимизации
        recent_performance = self.get_recent_performance(30)  # последние 30 записей
        
        # Оптимизация скорости обучения
        if self.is_performance_degrading(recent_performance):
            self.learning_rate *= 0.9  # замедление обучения
        elif self.is_performance_stable(recent_performance):
            self.learning_rate *= 1.05  # ускорение обучения
```

### 9. КОНТЕКСТУАЛЬНАЯ АДАПТАЦИЯ

#### 9.1 Адаптация к типу продукции
```python
def product_type_adaptation(self, product_type):
    """Адаптация к типу продукции"""
    
    # Базовые коэффициенты для разных типов
    product_coefficients = {
        'fish_fresh': {'a_multiplier': 1.2, 'b_multiplier': 1.1, 'c_multiplier': 1.0},
        'fish_smoked': {'a_multiplier': 0.8, 'b_multiplier': 0.9, 'c_multiplier': 0.9},
        'fish_dried': {'a_multiplier': 0.6, 'b_multiplier': 0.7, 'c_multiplier': 0.8}
    }
    
    if product_type in product_coefficients:
        coeffs = product_coefficients[product_type]
        return {
            'a': self.base_coefficients['a'] * coeffs['a_multiplier'],
            'b': self.base_coefficients['b'] * coeffs['b_multiplier'],
            'c': self.base_coefficients['c'] * coeffs['c_multiplier']
        }
    
    return self.base_coefficients
```

#### 9.2 Сезонная адаптация
```python
def seasonal_adaptation(self, date):
    """Сезонная адаптация модели"""
    
    month = date.month
    
    # Сезонные коэффициенты
    seasonal_factors = {
        (12, 1, 2): 1.15,   # Зима - повышенная усушка
        (3, 4, 5): 1.05,    # Весна - средняя усушка
        (6, 7, 8): 1.25,    # Лето - максимальная усушка
        (9, 10, 11): 1.10   # Осень - повышенная усушка
    }
    
    for months, factor in seasonal_factors.items():
        if month in months:
            return factor
    
    return 1.0  # Нейтральный коэффициент
```

### 10. МЕХАНИЗМЫ КОНТРОЛЯ АДАПТАЦИИ

#### 10.1 Валидация адаптации
```python
def validate_adaptation(self, new_coefficients, old_coefficients):
    """Валидация изменений коэффициентов"""
    
    # Проверка физических ограничений
    if not self.check_physical_constraints(new_coefficients):
        return False
    
    # Проверка разумности изменений
    max_change = 0.5  # максимальное изменение 50%
    for param in ['a', 'b', 'c']:
        change = abs(new_coefficients[param] - old_coefficients[param]) / old_coefficients[param]
        if change > max_change:
            return False
    
    return True

def rollback_adaptation(self, previous_state):
    """Откат адаптации при проблемах"""
    self.base_coefficients = previous_state['coefficients']
    self.adaptation_factors = previous_state['factors']
```

### 11. ИНТЕРФЕЙС АДАПТАЦИИ

#### 11.1 API для адаптации
```python
class ShrinkageAdaptationAPI:
    def update_with_inventory(self, inventory_results):
        """Обновление модели по результатам инвентаризации"""
        # Анализ результатов инвентаризации
        # Адаптация коэффициентов
        # Обновление моделей партий
        
    def update_with_environmental_data(self, temp, humidity):
        """Обновление с учетом условий хранения"""
        # Обновление факторов адаптации
        # Коррекция прогнозов
        
    def get_adapted_coefficients(self, context=None):
        """Получение адаптированных коэффициентов"""
        # Возврат коэффициентов с учетом всех факторов
```

### 12. ПРЕИМУЩЕСТВА АДАПТИВНОЙ МОДЕЛИ

#### 12.1 Гибкость
- Работа с периодами разной длительности
- Учет особенностей каждой партии
- Адаптация к изменяющимся условиям
- **Пер-номенклатурный учет излишка при поступлении**

#### 12.2 Точность
- Самообучение на основе реальных данных
- Минимизация прогнозных ошибок
- Учет множества факторов влияния

#### 12.3 Стабильность
- Защита от резких изменений
- Валидация всех адаптаций
- Возможность отката при проблемах

### 13. ИНТЕГРАЦИЯ С СУЩЕСТВУЮЩЕЙ СИСТЕМОЙ

#### 13.1 Совместимость
Адаптивная модель полностью совместима с существующей архитектурой:
- Использует те же базовые библиотеки (scipy, numpy)
- Сохраняет интерфейс коэффициентов (a, b, c)
- Поддерживает экспорт в те же форматы
- **Поддерживает пер-номенклатурный учет излишка при поступлении**

#### 13.2 Постепенное внедрение
Внедрение может происходить поэтапно:
1. Добавление адаптивных компонентов
2. Постепенная замена базовой модели
3. Полная интеграция с сохранением обратной совместимости

Эта адаптивная система позволяет модели автоматически подстраиваться под различные условия и обеспечивать максимальную точность прогнозов усушки с учетом индивидуальных характеристик каждой номенклатуры.