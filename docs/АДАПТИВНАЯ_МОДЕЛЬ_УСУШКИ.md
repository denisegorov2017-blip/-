```python
class AdaptiveShrinkageModel:
    def __init__(self):
        # Словарь процентов излишка по номенклатурам
        self.surplus_rates = {}  # {nomenclature: surplus_rate}
        # Средний процент излишка при поступлении (для обратной совместимости)
        self.average_surplus_rate = 0.0  # 0% по умолчанию
        
    def set_surplus_rate(self, surplus_rate, nomenclature=None):
        """
        Установка процента излишка при поступлении.
        
        Args:
            surplus_rate: Процент излишка (например, 0.05 для 5% излишка)
            nomenclature: Номенклатура (если None, устанавливает глобальное значение)
        """
        if nomenclature is None:
            # Установка глобального значения (для обратной совместимости)
            self.average_surplus_rate = surplus_rate
        else:
            # Установка значения для конкретной номенклатуры
            self.surplus_rates[nomenclature] = surplus_rate
    
    def get_surplus_rate(self, nomenclature=None):
        """
        Получение процента излишка при поступлении.
        
        Args:
            nomenclature: Номенклатура (если None, возвращает глобальное значение)
            
        Returns:
            float: Процент излишка
        """
        if nomenclature is not None and nomenclature in self.surplus_rates:
            return self.surplus_rates[nomenclature]
        return self.average_surplus_rate
    
    def _correct_for_surplus(self, data, nomenclature=None):
        """Коррекция данных с учетом излишка при поступлении"""
        # Получаем процент излишка для данной номенклатуры
        surplus_rate = self.get_surplus_rate(nomenclature)
        
        if surplus_rate == 0:
            return data.copy()
        
        corrected_data = data.copy()
        
        # Корректируем начальный баланс и приход с учетом излишка
        if 'initial_balance' in corrected_data:
            corrected_data['initial_balance'] = (
                corrected_data['initial_balance'] * (1 + surplus_rate)
            )
        
        if 'incoming' in corrected_data:
            corrected_data['incoming'] = (
                corrected_data['incoming'] * (1 + surplus_rate)
            )
        
        return corrected_data
    
    def predict_with_adaptation(self, t, 
                               environmental_conditions=None,
                               product_type=None,
                               date=None,
                               initial_balance=None,
                               nomenclature=None):
        """
        Прогноз усушки с учетом адаптационных факторов и излишка.
        
        Args:
            t: Время в днях
            environmental_conditions: Условия хранения
            product_type: Тип продукции
            date: Дата для сезонной адаптации
            initial_balance: Начальный баланс (для коррекции излишка)
            nomenclature: Номенклатура (для учета излишка)
        """
        # Базовый прогноз
        base_prediction = self._exponential_model(t, **self.base_coefficients)
        
        # Применяем адаптационные факторы
        adaptation_multiplier = self._calculate_adaptation_multiplier(
            environmental_conditions, product_type, date)
        
        # Получаем процент излишка для данной номенклатуры
        surplus_rate = self.get_surplus_rate(nomenclature)
        
        # Корректируем прогноз с учетом излишка при поступлении
        if initial_balance is not None and surplus_rate != 0:
            corrected_balance = initial_balance * (1 + surplus_rate)
            correction_factor = corrected_balance / initial_balance if initial_balance > 0 else 1.0
            return base_prediction * adaptation_multiplier * correction_factor
        
        return base_prediction * adaptation_multiplier
```

#### 7.4 Пример использования
```python
# Создание модели
model = AdaptiveShrinkageModel()

# Установка процента излишка для конкретной номенклатуры
model.set_surplus_rate(0.05, "СКУМБРИЯ ХК")  # 5% излишка для скумбрии
model.set_surplus_rate(0.10, "СЕЛЬДЬ ХК")    # 10% излишка для сельди

# Данные для адаптации
data = {
    'initial_balance': 100.0,  # Документированный остаток
    'incoming': 0,
    'outgoing': 0,
    'final_balance': 99.75,    # Фактический конечный остаток с учетом излишка
    'storage_days': 7
}

# Адаптация коэффициентов (автоматически учитывает излишек для конкретной номенклатуры)
coefficients = model.adapt_coefficients(data, nomenclature="СКУМБРИЯ ХК")

# Прогноз усушки для нового периода с учетом излишка
forecast = model.predict_with_adaptation(
    t=7, 
    initial_balance=100.0,
    nomenclature="СКУМБРИЯ ХК"
)

print(f"Прогноз усушки для СКУМБРИИ ХК: {forecast:.2f} кг")

# Для номенклатуры без установленного излишка будет использовано значение по умолчанию
forecast_default = model.predict_with_adaptation(
    t=7, 
    initial_balance=100.0,
    nomenclature="ОКУНЬ ХК"  # Не установлен излишек, будет использовано значение по умолчанию
)

print(f"Прогноз усушки для ОКУНЯ ХК: {forecast_default:.2f} кг")
```

### 8. САМООБУЧАЮЩАЯСЯ МОДЕЛЬ

#### 8.1 Алгоритм самообучения
```python
class SelfLearningShrinkageModel:
    def __init__(self):
        self.performance_history = []
        self.model_versions = {}
        self.best_model = None
        
    def learn_from_results(self, actual_results, predicted_results):
        """Обучение на основе сравнения прогнозов с реальностью"""
        
        # 1. Расчет ошибки
        error = self.calculate_prediction_error(actual_results, predicted_results)
        
        # 2. Обновление истории производительности
        self.performance_history.append({
            'timestamp': datetime.now(),
            'error': error,
            'model_version': self.current_version
        })
        
        # 3. Адаптация параметров обучения
        if error > self.acceptable_error_threshold:
            self.adjust_learning_parameters(error)
            
        # 4. Создание новой версии модели при необходимости
        if self.should_create_new_version(error):
            self.create_model_version()
            
    def auto_tune_parameters(self):
        """Автоматическая настройка параметров"""
        
        # Анализ истории для оптимизации
        recent_performance = self.get_recent_performance(30)  # последние 30 записей
        
        # Оптимизация скорости обучения
        if self.is_performance_degrading(recent_performance):
            self.learning_rate *= 0.9  # замедление обучения
        elif self.is_performance_stable(recent_performance):
            self.learning_rate *= 1.05  # ускорение обучения
```

### 9. КОНТЕКСТУАЛЬНАЯ АДАПТАЦИЯ

#### 9.1 Адаптация к типу продукции
```python
def product_type_adaptation(self, product_type):
    """Адаптация к типу продукции"""
    
    # Базовые коэффициенты для разных типов
    product_coefficients = {
        'fish_fresh': {'a_multiplier': 1.2, 'b_multiplier': 1.1, 'c_multiplier': 1.0},
        'fish_smoked': {'a_multiplier': 0.8, 'b_multiplier': 0.9, 'c_multiplier': 0.9},
        'fish_dried': {'a_multiplier': 0.6, 'b_multiplier': 0.7, 'c_multiplier': 0.8}
    }
    
    if product_type in product_coefficients:
        coeffs = product_coefficients[product_type]
        return {
            'a': self.base_coefficients['a'] * coeffs['a_multiplier'],
            'b': self.base_coefficients['b'] * coeffs['b_multiplier'],
            'c': self.base_coefficients['c'] * coeffs['c_multiplier']
```